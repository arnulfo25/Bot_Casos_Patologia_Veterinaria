import logging
import fitz  # PyMuPDF
import requests
import tempfile
import os
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, filters, ContextTypes

TELEGRAM_TOKEN = "7702196188:AAFIHlIzAF8q_WMfGxCt9alSYeKqUyirHc4"
API_KEY = "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"
MODEL_NAME = "qwen/qwen3-235b-a22b:free"

logging.basicConfig(level=logging.INFO)

INTRO = (
    "👋 ¡Bienvenido al Bot de Patología Veterinaria!\n\n"
    "Envía un artículo científico en PDF y la IA generará un caso clínico para que practiques. "
    "El caso incluirá historia clínica, anamnesis, pruebas diagnósticas, identificación de lesiones y diagnóstico definitivo.\n\n"
    "Simplemente adjunta tu PDF y espera la respuesta."
)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(INTRO)

def extract_text_from_pdf(pdf_path):
    doc = fitz.open(pdf_path)
    text = ""
    for page in doc:
        text += page.get_text()
    print(f"Texto extraído del PDF (primeros 500 caracteres): {text[:500]}")  # <-- Agrega esto
    return text

def generate_case_from_text(text):
    prompt = (
        "A partir del siguiente artículo científico, genera un caso clínico veterinario para practicar. "
        "Incluye historia clínica, anamnesis, pruebas de laboratorio o diagnósticas, identificación de lesiones, resultados y diagnóstico definitivo. "
        "Texto del artículo:\n\n" + text[:3000]
    )
    headers = {
        "Authorization": f"Bearer {API_KEY}",
        "Content-Type": "application/json"
    }
    data = {
        "model": MODEL_NAME,
        "messages": [{"role": "user", "content": prompt}]
    }
    response = requests.post(
        "https://openrouter.ai/api/v1/chat/completions",  # <-- URL correcta
        headers=headers,
        json=data,
        timeout=120
    )
    if response.status_code == 200:
        return response.json()['choices'][0]['message']['content']
    else:
        return "Ocurrió un error al generar el caso clínico."

async def handle_pdf(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message.document or not update.message.document.file_name.endswith('.pdf'):
        await update.message.reply_text("Por favor, envía un archivo PDF.")
        return

    file = await context.bot.get_file(update.message.document.file_id)
    with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as tmp_file:
        await file.download_to_drive(tmp_file.name)
        pdf_path = tmp_file.name

    await update.message.reply_text("Procesando el PDF, esto puede tardar unos segundos...")

    try:
        text = extract_text_from_pdf(pdf_path)
        if not text.strip():
            await update.message.reply_text("No se pudo extraer texto del PDF. ¿Es un PDF escaneado o vacío?")
            return
        case = generate_case_from_text(text)
        # Divide el mensaje si es muy largo
        for i in range(0, len(case), 4096):
            await update.message.reply_text(case[i:i+4096])
    except Exception as e:
        logging.error(e)
        await update.message.reply_text("Ocurrió un error procesando el PDF.")
    finally:
        os.remove(pdf_path)

def main():
    app = ApplicationBuilder().token(TELEGRAM_TOKEN).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.Document.MimeType("application/pdf"), handle_pdf))
    print("Bot corriendo...")
    app.run_polling()

if __name__ == "__main__":
    main()
